<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HF Propagation Monitor & Alarm</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:20px;background:#0b1020;color:#e6eef8}
    .card{background:rgba(255,255,255,0.03);padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.6);margin-bottom:12px}
    h1{font-size:20px;margin:0 0 8px}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:12px}
    .bands{display:flex;flex-wrap:wrap;gap:8px}
    .band{padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);min-width:120px}
    .open{border:2px solid #00ff99}
    .closed{opacity:0.6}
    label{display:block;margin-bottom:6px}
    button{padding:8px 12px;border-radius:8px;border:none;background:#0ea5a2;color:#012;cursor:pointer}
    small{color:#a8c0d8}
    .muted{opacity:0.6;font-size:13px}
  </style>
</head>
<body>
  <div class="card">
    <h1>HF Propagation Monitor & Alarm</h1>
    <p>Fetches NOAA SWPC space-weather JSON and uses a simple heuristic to estimate whether amateur HF bands are likely open. You can enable alarms per-band and allow desktop notifications.</p>
    <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
      <label><input type="checkbox" id="notifyPermission"> Request notifications & enable audio</label>
      <button id="testAlarm">Test alarm</button>
    </div>
  </div>

  <div class="grid">
    <div>
      <div class="card">
        <h2>Live Indices</h2>
        <div id="indices">Loading...</div>
      </div>

      <div class="card">
        <h2>Bands</h2>
        <div class="bands" id="bands">
          <!-- band panels injected here -->
        </div>
      </div>

      <div class="card">
        <h2>Log</h2>
        <div id="log" style="max-height:240px;overflow:auto;font-family:monospace;font-size:13px;background:rgba(0,0,0,0.12);padding:8px;border-radius:6px"></div>
      </div>
    </div>

    <div>
      <div class="card">
        <h2>Controls</h2>
        <label>Polling interval (seconds): <input id="interval" type="number" value="60" min="10" style="width:80px" /></label>
        <label>Enable automatic alarms: <input id="autoAlarm" type="checkbox" checked /></label>
        <p style="margin-top:8px"><small>Heuristic (simplified): uses 10.7cm solar flux (SFI) and planetary K-index (Kp). This is <em>not</em> a replacement for propagation prediction tools (VOACAP, DX clusters). It gives a quick local alarm if conditions look favourable.</small></p>
      </div>

      <div class="card">
        <h2>API status</h2>
        <div id="apiStatus">Not checked yet</div>
        <p><small>Data sourced from NOAA SWPC JSON endpoints (public). If you run this locally on a browser that blocks cross-origin requests, you may need to run via an allowed origin or a small proxy.</small></p>
      </div>

      <div class="card">
        <h2>About</h2>
        <p><small>Created for quick monitoring of HF band openings. Heuristics used in this demo (SFI and Kp) are intentionally simple so you can customize them.</small></p>
      </div>
    </div>
  </div>

  <!-- No base64 audio src here. Use Web Audio API to generate a short beep that's compatible with sandboxed environments. -->

  <script>
    // --- Configuration ---
    const endpoints = {
      planetaryK: 'https://services.swpc.noaa.gov/json/planetary_k_index_1m.json',
      solarRadio: 'https://services.swpc.noaa.gov/json/solar-radio-flux.json'
    };

    const bands = [
      {name:'160m', key:'160', enabled:true},
      {name:'80m', key:'80', enabled:true},
      {name:'40m', key:'40', enabled:true},
      {name:'20m', key:'20', enabled:true},
      {name:'15m', key:'15', enabled:true},
      {name:'10m', key:'10', enabled:true}
    ];

    // Create UI band cards
    const bandsDiv = document.getElementById('bands');
    bands.forEach(b=>{
      const el = document.createElement('div'); el.className='band closed'; el.id='band-'+b.key;
      el.innerHTML = `<strong>${b.name}</strong><div id="band-${b.key}-state">Unknown</div><label><input type="checkbox" class="alarmToggle" data-key="${b.key}" ${b.enabled? 'checked':''}/> Alarm</label>`;
      bandsDiv.appendChild(el);
    });

    const logEl = document.getElementById('log');
    const apiStatus = document.getElementById('apiStatus');

    function log(msg){
      const t = new Date().toISOString();
      logEl.innerHTML = `[${t}] ${msg}\n` + logEl.innerHTML;
    }

    async function fetchJson(url){
      try{
        const r = await fetch(url, {cache:'no-store'});
        if(!r.ok) throw new Error('HTTP '+r.status);
        return await r.json();
      }catch(e){
        log('Fetch error '+url+': '+e.message);
        throw e;
      }
    }

    // Simple heuristics to decide 'open'
    function decideOpen(sfi, kp){
      // sfi: number (10.7cm flux), kp: latest planetary Kp (0-9)
      const states = {};
      // high bands: 10/15/20
      if(sfi >= 120 && kp <= 4){ states['10']=true; states['15']=true; states['20']=true; }
      else if(sfi >= 90 && kp <= 4){ states['20']=true; states['15']=false; states['10']=false; }
      else { states['10']=false; states['15']=false; states['20']=false; }

      // 40m/80m: more ionospheric/night activity; we'll generously state open unless extreme storm
      if(kp >= 6){ states['40']=false; states['80']=false; }
      else { states['40']=true; states['80']=true; }

      // 160m: usually needs quiet geomagnetic conditions
      states['160'] = (kp <= 3 && sfi < 120);
      return states;
    }

    // Use Web Audio API to play a short beep that's widely supported (avoids relying on a specific audio file format).
    let audioCtx = null;
    function ensureAudioContext(){
      if(audioCtx) return audioCtx;
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        if(!AC){ log('Web Audio API not supported in this browser'); return null; }
        audioCtx = new AC();
        return audioCtx;
      }catch(e){ log('Failed to create AudioContext: '+e.message); return null; }
    }

    function playBeep(durationMs = 350, frequency = 880){
      const ctx = ensureAudioContext();
      if(!ctx){ log('No audio available'); return; }
      try{
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = frequency;
        g.gain.value = 0.0001; // start very quiet to avoid click
        o.connect(g);
        g.connect(ctx.destination);
        const now = ctx.currentTime;
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
        o.start(now);
        g.gain.exponentialRampToValueAtTime(0.0001, now + durationMs/1000);
        o.stop(now + durationMs/1000 + 0.05);
      }catch(e){ log('playBeep error: '+e.message); }
    }

    // Trigger alarm (desktop notif + beep)
    async function triggerAlarm(bandName){
      if(Notification && Notification.permission === 'granted'){
        try{ new Notification('HF band open', {body: `${bandName} looks open!`}); }catch(e){ log('Notification failed: '+e.message); }
      }
      // Attempt to resume audio context on user gesture if suspended
      const ctx = ensureAudioContext();
      if(ctx && ctx.state === 'suspended'){
        ctx.resume().catch(()=>{/* ignore */});
      }
      // Play beep (wrapped to avoid unhandled promise errors)
      try{ playBeep(); }catch(e){ log('Alarm sound failed: '+e.message); }
      log('Alarm triggered for '+bandName);
    }

    // Track previous open state to avoid repeated alarms
    let prevOpen = {};
    bands.forEach(b=> prevOpen[b.key] = false);

    async function update(){
      try{
        apiStatus.textContent = 'Fetching...';
        const [kpJson, sfiJson] = await Promise.all([
          fetchJson(endpoints.planetaryK),
          fetchJson(endpoints.solarRadio)
        ]);

        // pick latest Kp entry
        const latestK = Array.isArray(kpJson) && kpJson.length ? kpJson[kpJson.length-1] : null;
        const kpValue = latestK ? (latestK.kp || latestK.kp_est || latestK.value || 0) : 0;

        // pick latest solar radio flux entry (fields vary; find f107)
        const latestS = Array.isArray(sfiJson) && sfiJson.length ? sfiJson[sfiJson.length-1] : null;
        const sfiValue = latestS ? (latestS.solar_flux_10cm || latestS['f107'] || latestS['sfu'] || latestS['observed_value'] || latestS['flux'] || 0) : 0;

        apiStatus.textContent = `OK â€” last Kp: ${kpValue}, SFI(10.7cm): ${sfiValue}`;
        document.getElementById('indices').innerHTML = `Kp: <strong>${kpValue}</strong><br/>SFI (10.7cm): <strong>${sfiValue}</strong><br/>Updated: ${new Date().toLocaleString()}`;

        const openStates = decideOpen(Number(sfiValue), Number(kpValue));

        // update UI and alarms
        bands.forEach(b=>{
          const el = document.getElementById('band-'+b.key);
          const stateEl = document.getElementById(`band-${b.key}-state`);
          const isOpen = !!openStates[b.key];
          el.className = 'band ' + (isOpen? 'open':'closed');
          stateEl.textContent = isOpen ? 'Likely open' : 'Likely closed';

          const alarmCheckbox = el.querySelector('.alarmToggle');
          const alarmEnabled = alarmCheckbox && alarmCheckbox.checked;

          if(isOpen && alarmEnabled && !prevOpen[b.key] && document.getElementById('autoAlarm').checked){
            triggerAlarm(b.name);
          }
          prevOpen[b.key] = isOpen;
        });

      }catch(e){
        apiStatus.textContent = 'Error fetching data';
        log('Update error: '+(e && e.message ? e.message : String(e)));
      }
    }

    // initial
    update();

    let timer = null;
    function startTimer(){
      const s = Math.max(10, Number(document.getElementById('interval').value || 60));
      if(timer) clearInterval(timer);
      timer = setInterval(update, s*1000);
    }
    startTimer();

    document.getElementById('interval').addEventListener('change', startTimer);
    document.getElementById('autoAlarm').addEventListener('change', ()=>{ log('Auto alarm '+ (document.getElementById('autoAlarm').checked ? 'enabled':'disabled'));});

    // notifications & test
    document.getElementById('notifyPermission').addEventListener('change', async (ev)=>{
      if(ev.target.checked){
        try{
          const p = await Notification.requestPermission();
          log('Notification permission: '+p);
        }catch(e){ log('Notification permission request failed: '+e.message); }
      } else {
        log('Notifications & audio not requested by user');
      }
    });

    document.getElementById('testAlarm').addEventListener('click', ()=>{ triggerAlarm('TEST'); });

    // Persist alarm toggles
    document.querySelectorAll('.alarmToggle').forEach(cb=>{
      cb.addEventListener('change', ()=>{ log('Alarm for '+cb.dataset.key+' set to '+cb.checked); });
    });

    // very small safety: if browser blocks CORS, inform user
    window.addEventListener('error', (e)=>{ log('Error: '+(e && e.message ? e.message : String(e))); });

    // Informational note if Notifications are unsupported
    if(typeof Notification === 'undefined'){
      document.getElementById('notifyPermission').disabled = true;
      document.getElementById('notifyPermission').parentElement.insertAdjacentHTML('beforeend', '<span class="muted"> (Notifications not supported)</span>');
      log('Notifications not supported in this environment');
    }
  </script>
</body>
</html>
